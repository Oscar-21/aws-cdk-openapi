package blog.openapi.cdk.api.lambda;

import static java.util.Collections.singletonList;
import java.util.Map;
import org.jetbrains.annotations.NotNull;

import blog.openapi.cdk.api.AbstractCustomLambdaRuntime;
import blog.openapi.cdk.stacks.ApiStack;
import software.amazon.awscdk.BundlingOptions;
import software.amazon.awscdk.BundlingOutput;
import software.amazon.awscdk.DockerVolume;
import software.amazon.awscdk.Duration;
import software.amazon.awscdk.ILocalBundling;
import software.amazon.awscdk.services.lambda.AssetCode;
import software.amazon.awscdk.services.lambda.CfnFunction;
import software.amazon.awscdk.services.lambda.Function;
import software.amazon.awscdk.services.lambda.FunctionProps;
import software.amazon.awscdk.services.lambda.Code;
import software.amazon.awscdk.services.lambda.Permission;
import software.amazon.awscdk.services.lambda.Runtime;
import software.amazon.awscdk.services.logs.RetentionDays;
import software.amazon.awscdk.services.s3.assets.AssetOptions;
import software.amazon.awscdk.services.iam.ServicePrincipal;

public class BlogLambda extends AbstractCustomLambdaRuntime<ApiStack> {

  @Override
  public void buildImage(ApiStack stack) {
    /**
     * Additional configuration for the custom lambda docker container.
     */
    BundlingOptions.Builder apiBuilderOptions =
        BundlingOptions.builder().command(nativeBuildingInstructions)
            .image(software.amazon.awscdk.services.lambda.Runtime.PROVIDED_AL2.getBundlingImage())
            .user("root")
            .local(new ILocalBundling() {

              @Override
              public @NotNull Boolean tryBundle(@NotNull String outputDir,
                  @NotNull BundlingOptions options) {
                 // Use container for all builds.
                return false;
              }
            }).outputType(BundlingOutput.ARCHIVED);

    /*
     * Declare the asset code that needs to be packaged(bundled) for the custom java lambda runtime.
     */
    AssetCode apiCode = Code.fromAsset("../app/", AssetOptions.builder()
        .bundling(apiBuilderOptions.command(defaultApiPackagingInstructions).build()).build());

    /**
     * Create a lambda cloudformation resource referencing the local docker image that references
     * the quarkus http lambda
     */
    Function apiLambda = new Function(stack, ApiStack.Config.LogicalIds.OpenAPIBlogLambda,
        FunctionProps.builder()
            .runtime(Runtime.PROVIDED_AL2)
            .code(apiCode)
            .handler("not.used.in.provided.runtime")
            .memorySize(512).timeout(Duration.seconds(30)).logRetention(RetentionDays.ONE_DAY)
            .environment(Map.of("DISABLE_SIGNAL_HANDLERS", "true"))
            .build());

    /**
     * Get the construct for the API Lambda and override the Logical ID generated by the CDK.
     * 
     * This Logical ID is referenced in the ../app/api/openapi.yaml like so:
     * x-amazon-apigateway-integration: uri: Fn::Sub:
     * "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${APILambda.Arn}/invocations"
     */
    CfnFunction apiCfnFunction = (CfnFunction) apiLambda.getNode().getDefaultChild();
    apiCfnFunction.overrideLogicalId(ApiStack.Config.LogicalIds.APILambda);

    /**
     * Set Permissions on the APILambda created in the previous code block
     */
    Permission lamdaAPIGatewayPermission =
        Permission.builder().principal(new ServicePrincipal("apigateway.amazonaws.com")).build();
    apiLambda.addPermission("API GW Permission", lamdaAPIGatewayPermission);

  }
}
